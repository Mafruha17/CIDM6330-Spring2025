# **Schema Documentation**

## **Overview**
This document describes the schemas used in **Assignment 03** for managing **Patients, Providers, and Devices** in a FastAPI application. These schemas define the **data structure**, enforce **validation rules**, and facilitate the implementation of the **Repository Pattern** for multiple storage options (**SQLModel, CSV, In-Memory**).

---

## **Purpose of Schemas in Assignment 03**
Schemas serve as **Data Transfer Objects (DTOs)** ensuring:
- **Data consistency** across different repositories.
- **Validation of API requests** using Pydantic.
- **Repository Pattern compliance**, allowing flexible storage mechanisms.
- **Relationships between entities** (e.g., Patients and their Providers/Devices).

Each schema ensures that API requests and responses adhere to the expected data format, regardless of where the data is stored (**SQL database, CSV file, or in-memory storage**).

---

## **Schema Implementations**

### **ðŸ”¹ Patient Schema (`schemas/patient.py`)**

#### âœ… **Alignment with Requirements:**
- Used in **CRUD operations** for Patient entities.
- Ensures **validation** across different repositories.
- Guarantees **API data consistency**.

#### **Schema Definition:**
```python
from pydantic import BaseModel, EmailStr
from typing import Optional, List

class PatientSchema(BaseModel):
    id: Optional[int] = None  # ID is auto-generated by the database
    name: str
    email: EmailStr
    age: int
    active: bool
    devices: List[int] = []  # List of device IDs associated with the patient
    providers: List[int] = []  # List of provider IDs associated with the patient

    class Config:
        from_attributes = True  # Allow ORM support
```
#### **How it Meets Assignment Requirements:**
- **Ensures patient entity validation** across different storage methods.
- **Supports repository abstraction**, making the API independent of specific storage implementations.
- **ORM Compatibility (`from_attributes=True`)** allows seamless database integration.
- **List Fields (`devices`, `providers`)** enforce **relationships**.

---

### **ðŸ”¹ Provider Schema (`schemas/provider.py`)**

#### âœ… **Alignment with Requirements:**
- Defines **Provider entity** for CRUD operations.
- Allows **relationships between providers & patients**.

#### **Schema Definition:**
```python
from pydantic import BaseModel, EmailStr
from typing import Optional

class ProviderSchema(BaseModel):
    id: Optional[int] = None  # ID is auto-generated by the database
    name: str
    email: EmailStr
    specialty: str

    class Config:
        from_attributes = True  # Allow ORM support
```
#### **How it Meets Assignment Requirements:**
- **Validates provider information** before storage.
- **Ensures compatibility across multiple storage options** (SQL, CSV, In-Memory).
- **Enhances API reusability** by ensuring schema consistency.

---

### **ðŸ”¹ Device Schema (`schemas/device.py`)**

#### âœ… **Alignment with Requirements:**
- Defines **Device entity** for CRUD operations.
- Supports **relationships between devices & patients**.

#### **Schema Definition:**
```python
from pydantic import BaseModel
from typing import Optional

class DeviceSchema(BaseModel):
    id: Optional[int] = None  # ID is auto-generated by the database
    name: str
    type: str
    patient_id: Optional[int]  # Foreign key linking to Patient

    class Config:
        from_attributes = True  # Allow ORM support
```
#### **How it Meets Assignment Requirements:**
- **Allows devices to be linked to patients.**
- **Validates device information** before insertion.
- **Supports flexible repository pattern implementation.**

---

## **Schema Relationship to Repository Pattern**
The **Repository Pattern** abstracts data persistence, and these schemas serve as **interfaces** between the API and different storage mechanisms.

| **Repository**      | **Usage of Schemas** |
|---------------------|--------------------|
| **SQLModel Repository** | Maps schemas to ORM models (`Patient`, `Provider`, `Device`). |
| **CSV Repository**  | Converts schemas to **CSV rows** for persistence. |
| **In-Memory Repository** | Uses **Python dictionaries** with schema validation. |

âœ… **The schemas ensure that regardless of where data is stored, API contracts remain consistent.**

---

## **Relation to API & CRUD Operations**
These schemas are used in **API Routes** to enforce **input validation** and ensure **consistent API responses**.

For example, in `patient_routes.py`:
```python
@router.post("/")
def create_patient(patient: PatientSchema, db: Session = Depends(get_db)):
    return PatientRepository(db).create(patient)
```
- âœ… **Ensures all patient data adheres to schema rules** before being processed.
- âœ… **Abstracts data persistence**, so **changing repositories won't break the API**.

---

## **Conclusion**
- Schemas **define the API contract** between frontend requests and backend storage.
- They **support repository abstraction**, making the API **independent of storage type**.
- **Validation & consistency** are enforced **before storing data**.
- **Relationships between entities (Patient-Device-Provider)** are well-structured.

These schemas directly support **Assignment 03â€™s goal** of implementing a **Repository Pattern with multiple persistence strategies** while ensuring **data integrity and reusability**.

